import { supabase } from "../lib/supabaseClient.js";

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';

// Helper til at få auth token
async function getAuthToken() {
  const { data: { session } } = await supabase.auth.getSession();
  return session?.access_token;
}

// Hent alle beskeder fra en tråd via backend API
export async function fetchMessages(threadId) {
  try {
    const token = await getAuthToken();
    if (!token) {
      console.error("No auth token available");
      return [];
    }

    const response = await fetch(`${API_URL}/api/messages/thread/${threadId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch messages: ${response.status}`);
    }

    const { messages } = await response.json();
    console.log("Raw messages from API:", messages);
    return messages || [];
  } catch (error) {
    console.error("Error fetching messages:", error);
    return [];
  }
}

// Transformér databasebeskeder til Chat komponents format
export function transformMessages(
  databaseMessages,
  currentUserId,
  currentUserImage,
  friendImage,
  friendName = "Friend"
) {
  return databaseMessages.map((msg) => ({
    id: msg.message_id || msg.id || `${msg.thread_id}-${msg.user_id}-${msg.created_at}`,
    type: msg.user_id === currentUserId ? "user" : "friend",
    content: msg.message_content,
    senderId: msg.user_id,
    avatar: msg.user_id === currentUserId ? currentUserImage : friendImage,
    senderName: msg.user_id === currentUserId ? "You" : friendName,
    created_at: msg.created_at,
  }));
}

// Transformér beskeder til gruppechat format med deltagere map
export function transformGroupMessages(
  databaseMessages,
  currentUserId,
  participantsMap, // Map af user_id -> {avatar, name}
  currentUserAvatar // Den nuværende brugers avatar
) {
  return databaseMessages.map((msg) => {
    const isCurrentUser = msg.user_id === currentUserId;
    const participant = participantsMap[msg.user_id];
    
    return {
      id: msg.message_id || msg.id || `${msg.thread_id}-${msg.user_id}-${msg.created_at}`,
      type: isCurrentUser ? "user" : "friend",
      content: msg.message_content,
      senderId: msg.user_id,
      avatar: isCurrentUser ? currentUserAvatar : (participant?.avatar || "/assets/icons/user-circle.svg"),
      senderName: isCurrentUser ? "You" : (participant?.name || "Unknown"),
      created_at: msg.created_at,
    };
  });
}

// Send en besked via backend API
export async function sendMessage(threadId, userId, content) {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error("No auth token available");
    }

    const response = await fetch(`${API_URL}/api/messages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        thread_id: threadId,
        message_content: content
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Failed to send message: ${response.status}`);
    }

    const { messageData } = await response.json();
    return messageData;
  } catch (error) {
    console.error("Error sending message:", error);
    throw error;
  }
}

// Hent alle tråde for en bruger via backend API
export async function getUserThreads(userId) {
  try {
    const token = await getAuthToken();
    if (!token) {
      console.error("No auth token available");
      return [];
    }

    const response = await fetch(`${API_URL}/api/threads/user/${userId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch threads: ${response.status}`);
    }

    const { threads } = await response.json();
    return threads || [];
  } catch (error) {
    console.error("Error fetching user threads:", error);
    return [];
  }
}

// Hent kun gruppe threads (mer end 2 deltagere) for en bruger
export async function getUserGroupThreads(userId) {
  try {
    const token = await getAuthToken();
    if (!token) {
      console.error("No auth token available");
      return [];
    }

    // Hent alle threads via API
    const response = await fetch(`${API_URL}/api/threads/user/${userId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch threads: ${response.status}`);
    }

    const { threads } = await response.json();
    
    // Filter kun gruppethreads (thread_type === 'group' ELLER threads med mere end 2 deltagere)
    // Vi skal stadig tjekke deltagere via Supabase da API'en ikke returnerer det endnu
    const groupThreads = [];
    
    for (const thread of threads) {
      // Brug thread_type hvis tilgængelig
      if (thread.thread_type === 'group') {
        groupThreads.push(thread);
        continue;
      }
      
      // Ellers tjek antal deltagere
      const { data: participantCount } = await supabase
        .from("thread_participants")
        .select("user_id", { count: "exact" })
        .eq("thread_id", thread.thread_id);

      if (participantCount && participantCount.length > 2) {
        groupThreads.push(thread);
      }
    }

    // Sorter efter nyeste først
    return groupThreads.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

  } catch (error) {
    console.error("Error fetching user group threads:", error);
    return [];
  }
}

// Hent deltagere i en thread med deres profil data via backend API
export async function getThreadParticipantsWithProfiles(threadId) {
  try {
    const token = await getAuthToken();
    if (!token) {
      console.error("No auth token available");
      return [];
    }

    const response = await fetch(`${API_URL}/api/threads/${threadId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch thread: ${response.status}`);
    }

    const { thread } = await response.json();
    
    // Backend returnerer participants med profiles
    return thread.participants?.map(p => ({
      id: p.user_id,
      displayname: p.profiles?.displayname || 'Unknown',
      avatar: p.profiles?.user_image || null,
      role: p.role,
      joined_at: p.joined_at
    })) || [];

  } catch (error) {
    console.error("Error fetching thread participants with profiles:", error);
    return [];
  }
}
// Opdater gruppe navn
export async function updateGroupName(threadId, groupName) {
  try {
    const supabase = getSupabaseClient();

    const { data, error } = await supabase
      .from("threads")
      .update({ group_name: groupName })
      .eq("thread_id", threadId)
      .select()
      .single();

    if (error) throw error;

    return data;
  } catch (error) {
    console.error("Error updating group name:", error);
    throw error;
  }
}

// Opdater gruppe billede
export async function updateGroupImage(threadId, imageUrl) {
  try {
    const supabase = getSupabaseClient();

    const { data, error } = await supabase
      .from("threads")
      .update({ group_image: imageUrl })
      .eq("thread_id", threadId)
      .select()
      .single();

    if (error) throw error;

    return data;
  } catch (error) {
    console.error("Error updating group image:", error);
    throw error;
  }
}export async function getThread(threadId) {
  try {
    const supabase = getSupabaseClient();
    const { data, error } = await supabase
      .from("threads")
      .select("*")
      .eq("thread_id", threadId)
      .single();

    if (error) {
      if (error.code === "PGRST116") {
        // Ingen tråd fundet
        return null;
      }
      throw error;
    }
    return data;
  } catch (error) {
    console.error("Error fetching thread:", error);
    return null;
  }
}

// Opret eller hent en tråd mellem to brugere via backend API
export async function getOrCreateThread(user1Id, user2Id) {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error("No auth token available");
    }

    // Først forsøg at finde eksisterende thread
    const threadsResponse = await fetch(`${API_URL}/api/threads/user/${user1Id}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (threadsResponse.ok) {
      const { threads } = await threadsResponse.json();
      
      // Find direct thread mellem disse to brugere
      for (const thread of threads) {
        if (thread.thread_type === 'direct') {
          // Tjek om den anden bruger er deltager (stadig via Supabase da API ikke giver deltager liste)
          const { data: participants } = await supabase
            .from("thread_participants")
            .select("user_id")
            .eq("thread_id", thread.thread_id);

          if (participants && participants.length === 2) {
            const userIds = participants.map(p => p.user_id);
            if (userIds.includes(user1Id) && userIds.includes(user2Id)) {
              return thread;
            }
          }
        }
      }
    }

    // Ingen eksisterende thread fundet, opret ny via backend
    const createResponse = await fetch(`${API_URL}/api/threads`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        participant_ids: [user2Id], // API tilføjer automatisk creator (user1)
        thread_type: 'direct'
      })
    });

    if (!createResponse.ok) {
      const errorData = await createResponse.json();
      throw new Error(errorData.error || `Failed to create thread: ${createResponse.status}`);
    }

    const { thread } = await createResponse.json();
    return thread;
  } catch (error) {
    console.error("Error getting or creating thread:", error);
    throw error;
  }
}

// Opret gruppe chat med flere deltagere via backend API
export async function createGroupThread(creatorId, participantIds, groupName = null) {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error("No auth token available");
    }

    const response = await fetch(`${API_URL}/api/threads`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        participant_ids: participantIds,
        thread_type: 'group',
        thread_name: groupName
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Failed to create group thread: ${response.status}`);
    }

    const { thread } = await response.json();
    return thread;
  } catch (error) {
    console.error("Error creating group thread:", error);
    throw error;
  }
}

  // Opret thread
  const { data: newThread, error: createError } = await supabase
    .from("threads")
    .insert({
      created_by_user_id: creatorId,
      thread_type: "group",
      thread_name: groupName,
      created_at: new Date().toISOString(),
    })
    .select()
    .single();

  if (createError) throw createError;

  // Tilføj alle deltagere (inklusiv skaberen)
  const allParticipants = [creatorId, ...participantIds];
  const participantsData = allParticipants.map(userId => ({
    thread_id: newThread.thread_id, 
    user_id: userId, 
    role: userId === creatorId ? "admin" : "member"
  }));

  const { error: participantsError } = await supabase
    .from("thread_participants")
    .insert(participantsData);

  if (participantsError) {
    // Rollback: slet thread hvis deltagere ikke kunne tilføjes
    await supabase.from("threads").delete().eq("thread_id", newThread.thread_id);
    throw participantsError;
  }

  return newThread;
}

// Slet en tråd og tilhørende beskeder
export async function deleteThread(threadId) {
  try {
    const supabase = getSupabaseClient();

    // Slet beskeder først pga. FK constraints
    const { error: messagesError } = await supabase
      .from("messages")
      .delete()
      .eq("thread_id", threadId);

    if (messagesError) throw messagesError;

    const { error: threadError } = await supabase
      .from("threads")
      .delete()
      .eq("thread_id", threadId);

    if (threadError) throw threadError;
  } catch (error) {
    console.error("Error deleting thread:", error);
    throw error;
  }
}

// Hent deltagere i en thread
export async function getThreadParticipants(threadId) {
  try {
    const supabase = getSupabaseClient();
    const { data, error } = await supabase
      .from("thread_participants")
      .select("user_id, role, joined_at, profiles(id, displayname, user_image)")
      .eq("thread_id", threadId);

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error("Error fetching thread participants:", error);
    return [];
  }
}

// Tilføj deltagere til en eksisterende thread (konverter til gruppe chat)
export async function addParticipantsToThread(threadId, newUserIds) {
  try {
    const supabase = getSupabaseClient();

    // Først hent den nuværende thread for at se type
    const { data: thread, error: threadError } = await supabase
      .from("threads")
      .select("thread_type, thread_id")
      .eq("thread_id", threadId)
      .single();

    if (threadError) throw threadError;

    // Hvis det er en direct chat, konverter til group
    if (thread.thread_type === "direct") {
      const { error: updateError } = await supabase
        .from("threads")
        .update({ thread_type: "group" })
        .eq("thread_id", threadId);

      if (updateError) throw updateError;
    }

    // Tilføj nye deltagere
    const participantsData = newUserIds.map(userId => ({
      thread_id: threadId,
      user_id: userId,
      role: "member",
      joined_at: new Date().toISOString()
    }));

    const { error: participantsError } = await supabase
      .from("thread_participants")
      .insert(participantsData);

    if (participantsError) throw participantsError;

    return true;
  } catch (error) {
    console.error("Error adding participants to thread:", error);
    throw error;
  }
}
